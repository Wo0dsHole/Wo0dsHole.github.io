<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Wo0dsHole">
  
  
  
  
  
  <link rel="canonical" href="https://Wo0dsHole.github.io/2020/ie-cve-2020-0674/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           CVE-2020-0674 | 二进制
       
  </title>
  <meta name="title" content="CVE-2020-0674 | 二进制">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/Wo0dsHole.github.io\/"
    },
    "articleSection" : "posts",
    "name" : "CVE-2020-0674",
    "headline" : "CVE-2020-0674",
    "description" : "CVE-2020-0674 Overview 漏洞存在于 IE jscript.dll中，是 2020年初 360和 Google抓到的 0day，也是所谓的 “双星” 漏洞之一。\n再此之前的几个月，已经有多次传闻抓到 IE的 Single UAF exploit，但一直没公开样本。\n年初分析 VT上的混淆样本后，明白了它由 Single UAF到 RCE的核心思路。 但要把这种技术推广运用，需要逆向更多的 IE 对象细节，也就没有深入。\n最近 F-secure的研究员公开了 x64 exploit以及 write-up。其中的分析非常好，很少见到分析得如此透彻的文章。看后便把 x86 exp写了。\n这篇 blog作为学习此漏洞过程中的梳理与总结，F-secure中已有内容不再重复。\nIE Single UAF to RCE What is \u0026ldquo;write\u0026rdquo;? 此 IE exp最大的亮点在于：它是如何由 Single UAF完成 RCE的？这就涉及到了对 “写” 本质的理解。\n“写” 对应于程序语言中的 “赋值”，在编译理论中这样的赋值也被称为 “副作用”（Side effect）。\n程序语言很大程度上是对现实世界的建模，对于副作用（“写”）的理解，《SICP》中一针见血地道出——它是对 “时间” 的模拟。\n程序中一个变量x在某一语句被赋值了，那么x在赋值前后便产生了差异，这种差异就体现出了 “时间” 的概念——（赋值前）x ！===（赋值后）x。\nAnother \u0026ldquo;write\u0026rdquo; 现在的漏洞利用，不论是 windows内核还是浏览器，大都是先达到任意地址读写，即获得 r\/w primitive。\n但这种写原语并没有展现出上面所说的 “写” 的全貌，它常是直接用于内存中某个已存在的对象，比如去反复修改 Object Head中的字段。",
    "inLanguage" : "en-us",
    "author" : "Wo0dsHole",
    "creator" : "Wo0dsHole",
    "publisher": "Wo0dsHole",
    "accountablePerson" : "Wo0dsHole",
    "copyrightHolder" : "Wo0dsHole",
    "copyrightYear" : "2020",
    "datePublished": "2020-06-08 15:28:07 \u002b0800 CST",
    "dateModified" : "2020-06-08 15:28:07 \u002b0800 CST",
    "url" : "https:\/\/Wo0dsHole.github.io\/2020\/ie-cve-2020-0674\/",
    "wordCount" : "366",
    "keywords" : [ "IE", "二进制"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://Wo0dsHole.github.io/">二进制</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://Wo0dsHole.github.io/">二进制</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">CVE-2020-0674</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://Wo0dsHole.github.io/" rel="author">Wo0dsHole</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-06-08 itemprop="datePublished">June 8, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://Wo0dsHole.github.io/categories/nday%E7%A7%AF%E7%B4%AF/"> Nday积累 </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <h1 id="cve-2020-0674">CVE-2020-0674</h1>
<h2 id="overview">Overview</h2>
<p>漏洞存在于 IE jscript.dll中，是 2020年初 360和 Google抓到的 0day，也是所谓的 “双星” 漏洞之一。</p>
<p>再此之前的几个月，已经有多次传闻抓到 IE的 Single UAF exploit，但一直没公开样本。</p>
<p>年初分析 VT上的混淆样本后，明白了它由 Single UAF到 RCE的核心思路。 但要把这种技术推广运用，需要逆向更多的 IE 对象细节，也就没有深入。</p>
<p>最近 F-secure的研究员公开了 x64 exploit以及 <a href="https://labs.f-secure.com/blog/internet-exploiter-understanding-vulnerabilities-in-internet-explorer/">write-up</a>。其中的分析非常好，很少见到分析得如此透彻的文章。看后便把 x86 exp写了。</p>
<p>这篇 blog作为学习此漏洞过程中的梳理与总结，F-secure中已有内容不再重复。</p>
<h2 id="ie-single-uaf-to-rce">IE Single UAF to RCE</h2>
<h3 id="what-is-write">What is &ldquo;write&rdquo;?</h3>
<p>此 IE exp最大的亮点在于：它是如何由 Single UAF完成 RCE的？这就涉及到了对 “写” 本质的理解。</p>
<p>“写” 对应于程序语言中的 “赋值”，在编译理论中这样的赋值也被称为 “副作用”（Side effect）。</p>
<p>程序语言很大程度上是对现实世界的建模，对于副作用（“写”）的理解，《SICP》中一针见血地道出——它是对 “时间” 的模拟。</p>
<p>程序中一个变量<code>x</code>在某一语句被赋值了，那么<code>x</code>在赋值前后便产生了差异，这种差异就体现出了 “时间” 的概念——（赋值前）x ！===（赋值后）x。</p>
<h3 id="another-write">Another &ldquo;write&rdquo;</h3>
<p>现在的漏洞利用，不论是 windows内核还是浏览器，大都是先达到任意地址读写，即获得 r/w primitive。</p>
<p>但这种写原语并没有展现出上面所说的 “写” 的全貌，它常是直接用于内存中某个已存在的对象，比如去反复修改 Object Head中的字段。</p>
<p>如果从模拟时间的角度去看写原语，当关注 “内存” 与 “对应对象” 在时间线（箭头连线）上的变化，图示如下。</p>
<p>写原语，如下图：</p>
<p><img src="https://wo0dshole.github.io%5Cpic%5C1.png" alt="1"></p>
<p>CVE-2020-0674中的基于多次 UAF的写，如下图：</p>
<p><img src="https://wo0dshole.github.io%5Cpic%5C2.png" alt="2"></p>
<p>对照来看，甚至可以感觉到 write primitive是对 Init时无法完全可控的弥补。</p>
<p>假设 IE JScript在解析一个对象的引用时，只要内存中数据相同，不关心初始化时对象具体的内存地址，那么上述两种写的效果便是等价的（在有 read primitive泄露地址的情况下）。</p>
<p>而 x86 JScript中<code>VAR</code>如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> VAR {<span style="color:#75715e">//size=0x10
</span><span style="color:#75715e"></span>    int32 type;<span style="color:#75715e">//+0
</span><span style="color:#75715e"></span>    <span style="color:#960050;background-color:#1e0010">？</span><span style="color:#75715e">//+4
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>obj_ptr;<span style="color:#75715e">//+8
</span><span style="color:#75715e"></span>    VAR <span style="color:#f92672">*</span>next_var_ptr;<span style="color:#75715e">//+C
</span><span style="color:#75715e"></span>};
</code></pre></div><p><code>fake VAR</code>也是 exp中可控初始化（通过 UAF）的起点，其中 <code>*obj_ptr</code>代表内存地址信息。如果此信息在 <code>VAR</code>创建之前没被记录保存用于后续的校验。那么在以 <code>VAR</code>为起点的对象伪造下，上述假设成立（JScript无法分辨 fake object），也即获得等效 write primitive。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">spray</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array();
<span style="color:#66d9ef">for</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">spray_size</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) <span style="color:#a6e22e">spray</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object();
</code></pre></div><p><img src="https://wo0dshole.github.io%5Cpic%5C3.png" alt="3"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> GcBlock {
    GcBlock <span style="color:#f92672">*</span>forward;<span style="color:#75715e">//+0
</span><span style="color:#75715e"></span>    GcBlock <span style="color:#f92672">*</span>backward;<span style="color:#75715e">//+4
</span><span style="color:#75715e"></span>    VAR storage[<span style="color:#ae81ff">64</span>];<span style="color:#75715e">//+8
</span><span style="color:#75715e"></span>};
</code></pre></div><p><img src="https://wo0dshole.github.io%5Cpic%5C4.png" alt="4"></p>
<p>在拥有 r/w primitive的情况下，完成最终的 RCE基本就是流程化的操作，没什么难度了。</p>
<h2 id="x86-exploit">x86 Exploit</h2>
<h3 id="type-confuse">Type Confuse</h3>
<pre><code>arr.sort([compareFunction])
</code></pre><p>漏洞成因是 JScript对 Array.sort() 中 compareFunction的参数没有在 GC中追踪，由此产生悬挂引用（dangle ref），进而导致 UAF。</p>
<p>一个 Bug之所以能利用，与 Bug能导致何种的 “意外” 密切相关。</p>
<p>在 JS引擎这种与用户交互密切的程序中，它的内存空间里存在着大量用户可操作的对象，而对象一般是 <code>Head+Body</code>的形式。</p>
<p>正常情况下， <code>Head</code>是 JS引擎自行管理，存有关键的管理信息，用户不可越过 JS引擎直接到达。<code>Body</code>才是用户可以操作的范围。</p>
<p>当 Bug导致了越权访问 <code>Head</code>的意外时，便有了可被利用的可能。</p>
<p>因而 UAF漏洞的 “自身条件” 很好，在有了 dangle ref的情况下，毕竟大多数对象 <code>Head</code>、<code>Body</code>存在大小差异，只要 <code>re-use</code>的对象与 <code>free</code>对象的存在 <code>Head-Body</code>的重叠，用户的输入便有了 JS引擎的特权（设置对象<code>Head</code>）。</p>
<p><img src="https://wo0dshole.github.io%5Cpic%5C5.png" alt="5"></p>
<p>这些虚线之间的区域，便是被用户（攻击者）通过漏洞从 JS引擎掠夺而来的 “无主之地”。整个漏洞利用的起点开始于此。</p>
<p>要使得这些重叠区域有利用意义，其实就是使得对重叠区域的解析，存在 “二义性”——free留下的 dangle ref 和 re-use 产生的 new ref，同时对重叠区进行 “合法” 解析，进而创造出 <code>Head+Body</code>完全可控的对象。</p>
<p>从上图可以很容易的引出对应 exp编写需要知道的三个细节：</p>
<ol>
<li>如何重用释放的内存？</li>
<li>free object、re-use object 内部细节</li>
<li>恰到好处的对齐安排</li>
</ol>
<p>对1——通过 <code>property name</code>，申请的内存大小逆向<code>NoRelAlloc::PvAlloc</code>可知：</p>
<pre><code>size            body                  head
x86:((len_of_property_name + 1) * 2 + 0x30) * 2 = 0x648
x64:((len_of_property_name + 1) * 2 + 0x40) * 2 = 0x970
</code></pre><p>对2—— <code>free object</code> 由上面的 <code>GcBlock</code>、<code>VAR</code>即可知。<code>re-use object</code>，<code>head</code>、<code>body</code>大小关系如上。<code>head</code>的结构为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> VVAL {<span style="color:#75715e">//size=0x30
</span><span style="color:#75715e"></span>    <span style="color:#f92672">?</span><span style="color:#75715e">//+0
</span><span style="color:#75715e"></span>    <span style="color:#f92672">?</span><span style="color:#75715e">//+4
</span><span style="color:#75715e"></span>    <span style="color:#f92672">?</span><span style="color:#75715e">//+8
</span><span style="color:#75715e"></span>    <span style="color:#f92672">?</span><span style="color:#75715e">//+c
</span><span style="color:#75715e"></span>    <span style="color:#f92672">?</span><span style="color:#75715e">//+10
</span><span style="color:#75715e"></span>    <span style="color:#f92672">?</span><span style="color:#75715e">//+14
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> hash; <span style="color:#75715e">//+18
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> name_length;<span style="color:#75715e">//+1c
</span><span style="color:#75715e"></span>    VVAL <span style="color:#f92672">*</span>next; <span style="color:#75715e">//+20
</span><span style="color:#75715e"></span>    <span style="color:#f92672">?</span><span style="color:#75715e">//+24
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> id_number;<span style="color:#75715e">//+28
</span><span style="color:#75715e"></span>    wchar_t name[]; <span style="color:#75715e">//+2c
</span><span style="color:#75715e"></span>};
</code></pre></div><p>对3——由于<code>re-use object</code>是<code>property name</code>，因此只需一个即可。内存中具体的对齐计算细节，通过 <code>!heap -flt s 648</code> 定位到布局的内存，观察计算即可。</p>
<p>要实现 Type Confuse，即构造如下布局：</p>
<p><img src="https://wo0dshole.github.io%5Cpic%5C6.png" alt="6"></p>
<p><code>VAR.next_ptr</code>可以设 0，对于整型的 <code>VAR.obj_ptr</code>是其代表的整型数值。</p>
<p>但为了后续完成 <code>read/write primitive</code>，内存布局要更复杂一些。因为在触发 <code>re-use</code> 的 <code>property name</code>之后继续创建 <code>property name</code>，会紧随着分配到 <code>GcBlock</code>剩余的空间里。</p>
<p><img src="https://wo0dshole.github.io%5Cpic%5C7.png" alt="7"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">for</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">overlay_size</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
    <span style="color:#a6e22e">overlay</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">variants</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#a6e22e">overlay</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">padding</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#a6e22e">overlay</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">leak</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#a6e22e">overlay</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">leaked_var</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">i</span>; 
}
</code></pre></div><ul>
<li>
<p><code>variants</code>用于 <code>re-use</code>占位</p>
</li>
<li>
<p><code>padding</code>用于对齐</p>
<p>使得之后 <code>leak</code> 的 <code>head</code> 中 <code>hash</code>字段和 <code>free VAR</code>对齐。</p>
</li>
<li>
<p><code>leak</code> 用于泄露 <code>leaked var</code>，</p>
<p>逆向<code>CaseInsensitiveComputeHashCch</code>可知，通过设置 <code>single char property name</code> 可使得 <code>property head</code> 中的 <code>hash</code> 字段可控。</p>
<p>而此后又是 <code>next ptr</code>字段。因此，通过<code>padding</code>对齐后，利用 <code>hash</code>伪造出浮点型 <code>VAR</code>，可泄露出得 <code>next ptr</code>。</p>
</li>
<li>
<p><code>leaked var</code> 用于定位</p>
<p>它存有 overlay[] 的索引<code>i</code>，后续将用于精确定位发生泄露的 overlay[i]，之后基于对它的反复 UAF，构建出 r/w primitive。</p>
</li>
</ul>
<h3 id="fake-object">Fake Object</h3>
<h3 id="read-primitive">Read primitive</h3>
<h3 id="ntcontinue">NtContinue</h3>
<h2 id="question">Question</h2>
<h3 id="spray-and-gc">Spray and GC</h3>
<h3 id="context">CONTEXT</h3>
<h3 id="patch-diff">Patch Diff</h3>
<h3 id="ntdll-base">Ntdll Base</h3>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Wo0dsHole </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://Wo0dsHole.github.io/2020/ie-cve-2020-0674/>https://Wo0dsHole.github.io/2020/ie-cve-2020-0674/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://Wo0dsHole.github.io/tags/ie/">
                    #IE</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://Wo0dsHole.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
         
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">1993 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://Wo0dsHole.github.io/">Wo0dsHole</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
