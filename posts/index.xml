<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 树洞</title>
    <link>https://Wo0dsHole.github.io/posts/</link>
    <description>Recent content in Posts on 树洞</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 08 Jun 2020 15:28:07 +0800</lastBuildDate>
    
	<atom:link href="https://Wo0dsHole.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>0674</title>
      <link>https://Wo0dsHole.github.io/2020/2/</link>
      <pubDate>Mon, 08 Jun 2020 15:28:07 +0800</pubDate>
      
      <guid>https://Wo0dsHole.github.io/2020/2/</guid>
      <description>CVE-2020-0674 笔记  IE single UAF to RCE 利用思想 CVE-2020-0674 x86 exploit开发  概述 漏洞存在于 IE jscript.dll中，是 2020年初 360和 Google抓到的 0day，也是所谓的 “双星” 漏洞之一。
再其之前的几个月已经有多次传闻，抓到 IE的 single UAF exploit，但一直没公开样本。
当时初步分析混淆样本后，明白了它由 single UAF到 RCE的核心思路。 但要把这种技术推广运用，需要逆向更多的 IE 对象细节，也就没有深入了。
最近 F-secure的研究员公开了 x64 exploit以及 write-up。其中的分析非常好，甚至我很少见到分析得如此透彻的文章。
因而就顺带把 x86 exp写了，但其中也踩了一些坑。
写下这篇 blog，作为梳理和总结。
什么是“写” 此 IE exp最大的亮点在于，它是如何由 single UAF完成 RCE的？这就涉及到了对 “写” 本质的理解。
“写” 对应于程序语言中的 “赋值”。而纯函数式语言是没有赋值的，在编译理论中这样的赋值也被称为 “副作用”（Side effect）。
程序语言很大程度上是对现实世界的建模，对于副作用（“写”）的理解，《SICP》中一针见血地道出——它是对 “时间” 的模拟。
程序中一个变量x在某一句被赋值了，那么x在赋值前后便产生了差异，这种差异就体现出了 “时间”——（赋值前）x ！===（赋值后）x。
另一种“写” 现在的漏洞利用，不论是 windows内核还是浏览器，大都是先达到任意地址读写，即 r/w primitive。</description>
    </item>
    
    <item>
      <title>0674</title>
      <link>https://Wo0dsHole.github.io/2020/3/</link>
      <pubDate>Mon, 08 Jun 2020 15:28:07 +0800</pubDate>
      
      <guid>https://Wo0dsHole.github.io/2020/3/</guid>
      <description>CVE-2020-0674 笔记  IE single UAF to RCE 利用思想 CVE-2020-0674 x86 exploit开发  概述 漏洞存在于 IE jscript.dll中，是 2020年初 360和 Google抓到的 0day，也是所谓的 “双星” 漏洞之一。
再其之前的几个月已经有多次传闻，抓到 IE的 single UAF exploit，但一直没公开样本。
当时初步分析混淆样本后，明白了它由 single UAF到 RCE的核心思路。 但要把这种技术推广运用，需要逆向更多的 IE 对象细节，也就没有深入了。
最近 F-secure的研究员公开了 x64 exploit以及 write-up。其中的分析非常好，甚至我很少见到分析得如此透彻的文章。
因而就顺带把 x86 exp写了，但其中也踩了一些坑。
写下这篇 blog，作为梳理和总结。
什么是“写” 此 IE exp最大的亮点在于，它是如何由 single UAF完成 RCE的？这就涉及到了对 “写” 本质的理解。
“写” 对应于程序语言中的 “赋值”。而纯函数式语言是没有赋值的，在编译理论中这样的赋值也被称为 “副作用”（Side effect）。
程序语言很大程度上是对现实世界的建模，对于副作用（“写”）的理解，《SICP》中一针见血地道出——它是对 “时间” 的模拟。
程序中一个变量x在某一句被赋值了，那么x在赋值前后便产生了差异，这种差异就体现出了 “时间”——（赋值前）x ！===（赋值后）x。
另一种“写” 现在的漏洞利用，不论是 windows内核还是浏览器，大都是先达到任意地址读写，即 r/w primitive。</description>
    </item>
    
    <item>
      <title>0674</title>
      <link>https://Wo0dsHole.github.io/2020/ie-cve-2020-0674/</link>
      <pubDate>Mon, 08 Jun 2020 15:28:07 +0800</pubDate>
      
      <guid>https://Wo0dsHole.github.io/2020/ie-cve-2020-0674/</guid>
      <description>CVE-2020-0674 笔记  IE single UAF to RCE 利用思想 CVE-2020-0674 x86 exploit开发  概述 漏洞存在于 IE jscript.dll中，是 2020年初 360和 Google抓到的 0day，也是所谓的 “双星” 漏洞之一。
再其之前的几个月已经有多次传闻，抓到 IE的 single UAF exploit，但一直没公开样本。
当时初步分析混淆样本后，明白了它由 single UAF到 RCE的核心思路。 但要把这种技术推广运用，需要逆向更多的 IE 对象细节，也就没有深入了。
最近 F-secure的研究员公开了 x64 exploit以及 write-up。其中的分析非常好，甚至我很少见到分析得如此透彻的文章。
因而就顺带把 x86 exp写了，但其中也踩了一些坑。
写下这篇 blog，作为梳理和总结。
什么是“写” 此 IE exp最大的亮点在于，它是如何由 single UAF完成 RCE的？这就涉及到了对 “写” 本质的理解。
“写” 对应于程序语言中的 “赋值”。而纯函数式语言是没有赋值的，在编译理论中这样的赋值也被称为 “副作用”（Side effect）。
程序语言很大程度上是对现实世界的建模，对于副作用（“写”）的理解，《SICP》中一针见血地道出——它是对 “时间” 的模拟。
程序中一个变量x在某一句被赋值了，那么x在赋值前后便产生了差异，这种差异就体现出了 “时间”——（赋值前）x ！===（赋值后）x。
另一种“写” 现在的漏洞利用，不论是 windows内核还是浏览器，大都是先达到任意地址读写，即 r/w primitive。</description>
    </item>
    
  </channel>
</rss>