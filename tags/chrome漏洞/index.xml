<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chrome漏洞 on 树洞</title>
    <link>https://Wo0dsHole.github.io/tags/chrome%E6%BC%8F%E6%B4%9E/</link>
    <description>Recent content in Chrome漏洞 on 树洞</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Mar 1993 00:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://Wo0dsHole.github.io/tags/chrome%E6%BC%8F%E6%B4%9E/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>CVE-2019-5786笔记</title>
      <link>https://Wo0dsHole.github.io/1993/b0/</link>
      <pubDate>Sat, 13 Mar 1993 00:00:00 +0800</pubDate>
      
      <guid>https://Wo0dsHole.github.io/1993/b0/</guid>
      <description>CVE-2019-5786笔记 [TOC]
0.参考blog阅读 链接：https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/
这一部分基本是偏翻译性质的记录。
0.补丁分析 Google的简略漏洞公告信息知：FileReader的 UAF漏洞。
从MDN上了解 FileReader信息：
FileReader可使 web应用程序异步地读取用户计算机上存储的文件内容（或raw data buffers）。借助 File或 Blob对象去读取指定的文件或数据。用于读取用户打开的文件对话框中的文件内容，或由 js代码创建的 Blobs。
例子：
let reader = new FileReader(); reader.onloadend = function(evt) { console.log(`contents as an ArrayBuffer: ${evt.target.result}`); } reader.onprogress = function(evt) { console.log(`read ${evt.target.result.byteLength}bytes so far`); } let contents = &amp;#34;filecontents&amp;#34;; f = new File([contents], &amp;#34;a.txt&amp;#34;); reader.readAsArrayBuffer(f); 重点在于：
 File或 Blob内容是异步读取的 进程通过回调来通知用户 js代码  onprogress事件可能会被触发多次，当进程在读取、访问当前读取的内容时。
onloadend事件只在操作完成时被触发一次，不管操作是成功或失败。
补丁代码中只修改了一个函数，如下：
vul:
DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() { DCHECK_EQ(read_type_, kReadAsArrayBuffer); if (array_buffer_result_) return array_buffer_result_; // If the loading is not started or an error occurs, return an empty result.</description>
    </item>
    
  </channel>
</rss>